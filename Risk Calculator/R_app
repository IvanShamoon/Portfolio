library(shiny)
library(dplyr)
library(highcharter) 
library(plotly)
library(GEOquery) 
library(R.utils)
library(reshape2)
library(ggplot2)
library(limma)
library(dplyr)
library(DT)
library("annotate")
library("rat2302.db")
library("Biobase")
library("biomaRt")
library(dplyr)
library("hgu133a.db")
library("AnnotationDbi")
library(cvTools)
library(randomForest)
library(caret)
library(dplyr)
library(highcharter) 
library(cluster)
library(plotly)
library(clusterProfiler)
library(enrichplot)
library(ggplot2)
library(netgsa)
library(graphite)
library(data.table)
library("org.Hs.eg.db", character.only = TRUE)
library(DOSE)
library(enrichplot)
library(ggnewscale)
library(pathview)
library(MLmetrics)



# load series and platform data from GEO

# ------------------------------   training data set ---------------------------------------------------------------
gset <- getGEO("GSE15296", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL570", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

ex <- exprs(gset)
# log2 transform
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
  (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
ex <- log2(ex) }

gset$Outcome <- ifelse(grepl("phenotype: Well-functioning kidney transplant", gset$`characteristics_ch1.1`), "Stable", "Rejection")


# Convert gene id to gene symbol:
fSet <- fData(gset)



probeSet <- rownames(fSet)

e <- gset


mart <- useMart("ENSEMBL_MART_ENSEMBL")
mart <- useDataset("hsapiens_gene_ensembl", mart)

annotLookup <- getBM(
  mart = mart,
  attributes = c(
    "affy_hg_u133_plus_2",
    "ensembl_gene_id",
    "gene_biotype",
    "entrezgene_id",
    "external_gene_name"),
  filter = "affy_hg_u133_plus_2",
  values = rownames(exprs(e)),
  uniqueRows=TRUE)

order <- which(!duplicated(annotLookup$affy_hg_u133_plus_2))
annotLookup <- annotLookup[order,]


Gene <- data.frame(Symbol = annotLookup$external_gene_name, EntrezID = annotLookup$entrezgene_id, row.names = annotLookup$affy_hg_u133_plus_2)

reorder_idx <- match(rownames(Gene), rownames(e))

e <- e[reorder_idx,]

idx <- which(!is.na(Gene$Symbol) & !duplicated(Gene$Symbol))


e <- e[idx,]


Gene <- Gene[idx,]
rownames(e) <- Gene$Symbol


e <- e[which(rownames(e) != ""),] #get rid of empty rows which don't have a matching gene symbol




# ------ PCA PLOT ----------------
# PCA Plot:














# Feature selection: 
design <- model.matrix(~Outcome, data = pData(e))
fit <- lmFit(ex, design)
fit <- eBayes(fit)


tT <- topTable(fit, n = Inf) 
DT::datatable(round(tT[1:50, ], 2))

# Store top 50 DE genes in a vector: 

top50De <- apply(e, 1, var)
top50De = names(sort(top50De, decreasing = TRUE)[1:50])
top50De

featSub <- gset[rownames(e)%in%top50De,]
featSub

featSub_pca <- prcomp(t(exprs(featSub)), .scale = TRUE)
df_toplot <- data.frame(featSub$Outcome,
                        pc1 = featSub_pca$x[,1], pc2 = featSub_pca$x[,2]  )

# top 250 genes
design <- model.matrix(~Outcome, data = pData(e))
fit <- lmFit(ex, design)
fit <- eBayes(fit)

tT <- topTable(fit, n = Inf) 
DT::datatable(round(tT[1:250, ], 2))




# prediction model -> 
set.seed(3888)

X = as.matrix(t(exprs(e)))
y = gset$Outcome
y <- factor(y, levels = c("Rejection", "Stable")) #outputs a rejection or stable prediction for genes

# Performing feature selection -> top 50 DE genes
design <- model.matrix(~y) # just done on the training set
fit <- eBayes(lmFit(t(X), design)) #transposed
top50Genes = rownames(topTable(fit, n = 50))


X <- X[, top50Genes]



cvK = 5  # number of CV folds
cv_50acc5_knn = cv_50acc5_svm = cv_50acc5_rf = c()
cv_acc_knn = cv_acc_svm = cv_acc_rf = c()
f1_50_svm = f1_50_rf = f1_50_knn = c()


n_sim = 25 ## number of repeats
for (i in 1:n_sim) {
  
  cvSets = cvTools::cvFolds(nrow(X), cvK)  # permute all the data, into 5 folds
  cv_acc_knn = cv_acc_svm = cv_acc_rf = c()
  f1_folds_svm = f1_folds_rf = f1_folds_knn = c()

  
  for (j in 1:cvK) {
    
    #subsetting the training and test data
    test_id = cvSets$subsets[cvSets$which == j]
    X_test = X[test_id, ]
    X_train = X[-test_id, ]
    y_test = y[test_id]
    y_train = y[-test_id]
    
    
    
    ## KNN
    fit5 = class::knn(train = X_train, test = X_test, cl = y_train, k = 5)
    cv_acc_knn[j] = mean(fit5 == y_test)
    f1_knn = F1_Score(y_test, fit5)
    
    ## SVM
    svm_res <- e1071::svm(x = X_train, y = as.factor(y_train))
    fit <- predict(svm_res, X_test)
    cv_acc_svm[j] = mean(fit == y_test)
    f1_svm = F1_Score(y_test, fit)
    
    ## RandomForest
    rf_res <- randomForest::randomForest(x = X_train, y = as.factor(y_train))
    fit <- predict(rf_res, X_test)
    cv_acc_rf[j] = mean(fit == y_test)
    f1_rf = F1_Score(y_test, fit)
    
    ## Remove nan and NA from F1 scores
    if (is.nan(f1_knn)) {
      f1_knn = 0
    }
    if (is.na(f1_knn)) {
      f1_knn = 0
    }
    
        
    if (is.nan(f1_svm)) {
      f1_svm = 0
    }
    if (is.na(f1_svm)) {
      f1_svm = 0
    }
  
        
    if (is.nan(f1_rf)) {
      f1_rf = 0
    }
    if (is.na(f1_rf)) {
      f1_rf = 0
    }
    
    ## Append f1 scores for models
    f1_folds_svm = append(f1_folds_svm, f1_svm)
    f1_folds_knn = append(f1_folds_knn,f1_knn)
    f1_folds_rf = append(f1_folds_rf, f1_rf)

  }
  cv_50acc5_knn <- append(cv_50acc5_knn, mean(cv_acc_knn))
  cv_50acc5_svm <- append(cv_50acc5_svm, mean(cv_acc_svm))
  cv_50acc5_rf <- append(cv_50acc5_rf, mean(cv_acc_rf))
  f1_50_knn = append(f1_50_knn , mean(f1_folds_knn))
  f1_50_rf = append(f1_50_rf, mean(f1_folds_rf))
  f1_50_svm = append(f1_50_svm, mean(f1_folds_svm))
} ## end for

f1_knn = round(mean(f1_50_knn),2)
f1_rf = round(mean(f1_50_rf),2)
f1_svm = round(mean(f1_50_svm),2)


# pathway analysis code ----------------------------------------
organism = "org.Hs.eg.db" #human


# Store top 250 DE genes in a vector: 

top250De <- apply(e, 1, var)
top250De = names(sort(top250De, decreasing = TRUE)[1:250])



feat250 <- e[rownames(e)%in%top250De,] #top50genes from first dataset (training)



eg = bitr(rownames(feat250), fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
head(eg)



eg$ENTREZID

geneLs <- eg$ENTREZID
geneLs <- sort(geneLs, decreasing = TRUE)
geneSym <- eg$SYMBOL


# making a kegg object:

mkk2 <- enrichKEGG(geneLs,
                   organism = 'hsa',
                   pvalueCutoff = 0.05
)



# end ------------------ pathway analysis ----------------


# ------------------------------- END TRAINING DATA SET --------------------------------------------------------------

















# testing data set ---------------------------------------------------------------
gset2 <- getGEO("GSE129166", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL570", attr(gset2, "names")) else idx <- 1
gset2 <- gset2[[idx]]

ex2 <- exprs(gset2)
# log2 transform
qx <- as.numeric(quantile(ex2, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
  (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex2[which(ex2 <= 0)] <- NaN
ex2 <- log2(ex2) }


# Convert gene id to gene symbol:
fSet <- fData(gset2)
e2 <- gset2
mart <- useMart("ENSEMBL_MART_ENSEMBL")
mart <- useDataset("hsapiens_gene_ensembl", mart)
annotLookup <- getBM(
  mart = mart,
  attributes = c(
    "affy_hg_u133_plus_2",
    "ensembl_gene_id",
    "gene_biotype",
    "entrezgene_id",
    "external_gene_name"),
  filter = "affy_hg_u133_plus_2",
  values = rownames(exprs(e2)),
  uniqueRows=TRUE)
order <- which(!duplicated(annotLookup$affy_hg_u133_plus_2))
annotLookup <- annotLookup[order,]
Gene <- data.frame(Symbol = annotLookup$external_gene_name, EntrezID = annotLookup$entrezgene_id, row.names = annotLookup$affy_hg_u133_plus_2)
reorder_idx <- match(rownames(Gene), rownames(e2))
e2 <- e2[reorder_idx,]
idx <- which(!is.na(Gene$Symbol) & !duplicated(Gene$Symbol))
e2 <- e2[idx,]
Gene <- Gene[idx,]
rownames(e2) <- Gene$Symbol
e2 <- e2[which(rownames(e2) != ""),] #get rid of empty rows which don't have a matching gene symbol

tcmr <- gset2$`tcmr (no:ch1`
abmr <- gset2$`abmr (no:ch1`
outcome <- 'NA'
# create dataframe combining two columns: 
outcome_df <- data.frame(abmr, tcmr, outcome)
outcome_df
# Looping through dataframe and adding rejection/stable to new column
for (row in 1:nrow(outcome_df)) {
  if(grepl("0_Yes:1): 1", outcome_df[row, "abmr"])) {
    if(grepl("TCMR:2): 1", outcome_df[row, "tcmr"]) || grepl("TCMR:2): 2", outcome_df[row, "tcmr"])) {
      outcome_df[row, "outcome"] <- "Rejection"
    } else {
      # still rejection if abmr is classified as rejection
      outcome_df[row, "outcome"] <- "Rejection"
      
    }
  } else {
    outcome_df[row, "outcome"] <- "Stable"
  } 
}

# now we have outcome column -> replace "Outcome" column in gset2
gset2$Outcome <- outcome_df$outcome
table(gset2$Outcome)
pData(gset2)
table(gset2$Outcome)
gset2_pca <- prcomp(t(ex2), scale. = TRUE)
df_toplot2 <- data.frame(gset2$Outcome,
                         pc1 = gset2_pca$x[,1], pc2 = gset2_pca$x[,2])
featSub2 <- gset2[rownames(e2)%in%top50De,] #top50genes from first dataset (training)
top50Genes
# now performing PCA again:
featSub_pca <- prcomp(t(exprs(featSub2)))
df_toplot2 <- data.frame(featSub2$Outcome, 
                         pc1 = featSub_pca$x[,1], pc2 = featSub_pca$x[,2]  )


#Prediction
set.seed(3888)
X2 = as.matrix(t(exprs(e2)))
y2 = gset2$Outcome
y2 <- na.omit(y2)
y2 <- factor(y2, levels = c("Rejection", "Stable")) #outputs a rejection or stable prediction for genes
y2
X2 <- X2[, top50De] #top50Genes from the first dataset 1
X2 <- na.omit(X2)
cvK2 = 5  # number of CV folds
cv_50acc5_knn2 = cv_50acc5_svm2 = cv_50acc5_rf2 = c()
cv_acc_knn2 = cv_acc_svm2 = cv_acc_rf2 = c()
f1_50_svm = f1_50_rf = f1_50_knn = c()
n_sim2 = 25 ## number of repeats

for (i in 1:n_sim2) {
  cvSets2 = cvTools::cvFolds(nrow(X2), cvK2)  # permute all the data, into 5 folds
  cv_acc_knn2 = cv_acc_svm2 = cv_acc_rf2 = c()
  f1_folds_svm = f1_folds_rf = f1_folds_knn = c()

  
  for (j in 1:cvK2) {
    
    #subsetting the training and test data
    test_id2 = cvSets2$subsets[cvSets2$which == j]
    X_test2 = X2[test_id2, ]
    X_train2 = X2[-test_id2, ]
    y_test2 = y2[test_id2]
    y_train2 = y2[-test_id2]
    
    
    
    ## KNN
    fit52 = class::knn(train = X_train2, test = X_test2, cl = y_train2, k = 5)
    cv_acc_knn2[j] = mean(fit52 == y_test2)
    f1_knn = F1_Score(y_test2, fit52)
    
    ## SVM
    svm_res2 <- e1071::svm(x = X_train2, y = as.factor(y_train2))
    fit2 <- predict(svm_res2, X_test2)
    cv_acc_svm2[j] = mean(fit2 == y_test2)
    f1_svm = F1_Score(y_test2, fit2)
    
    ## RandomForest
    rf_res2 <- randomForest::randomForest(x = X_train2, y = as.factor(y_train2))
    fit2 <- predict(rf_res2, X_test2)
    cv_acc_rf2[j] = mean(fit2 == y_test2)
    f1_rf = F1_Score(y_test2, fit2)
    
    if (is.nan(f1_knn)) {
      f1_knn = 0
    }
    if (is.na(f1_knn)) {
      f1_knn = 0
    }
    
        
    if (is.nan(f1_svm)) {
      f1_svm = 0
    }
    if (is.na(f1_svm)) {
      f1_svm = 0
    }
    
        
    if (is.nan(f1_rf)) {
      f1_rf = 0
    }
    if (is.na(f1_rf)) {
      f1_rf = 0
    }
    
    f1_folds_svm = append(f1_folds_svm, f1_svm)
    f1_folds_knn = append(f1_folds_knn,f1_knn)
    f1_folds_rf = append(f1_folds_rf, f1_rf)
    
  }
  cv_50acc5_knn2 <- append(cv_50acc5_knn2, mean(cv_acc_knn2))
  cv_50acc5_svm2 <- append(cv_50acc5_svm2, mean(cv_acc_svm2))
  cv_50acc5_rf2 <- append(cv_50acc5_rf2, mean(cv_acc_rf2))
  f1_50_knn = append(f1_50_knn , mean(f1_folds_knn))
  f1_50_rf = append(f1_50_rf, mean(f1_folds_rf))
  f1_50_svm = append(f1_50_svm, mean(f1_folds_svm))
} ## end for

f1_knn_2 = round(mean(f1_50_knn),2)
f1_rf_2 = round(mean(f1_50_rf),2)
f1_svm_2 = round(mean(f1_50_svm),2)








# Define UI for application that draws a histogram
ui <- fluidPage(
  
  
  # Application title
  titlePanel(div("Risk Calculator for Renal Transplant Patients", style = "color: #0492C2")),
  
  
  
  
  # --------------------------(NAVBAR)BODY-------------------------------------
  
  
  
  navbarPage("Calculator",
             tabPanel("Home",
                      br(),
                      h2("Home Page"), br(),
                      h3("Welcome to the Risk Calculator for Post Renal Transplants"),br(),
                      "The aim of the calculator is to provide new insights into the prediction of post renal transplant outcomes, and associated biological pathways with significant genes.", br(),
                      h3("How to use the Calculator"), br(),
                      h4("1. Click the GSE15296 Training Data tab, there is a menu which contains Description, Exploration, Initial Data Analysis, Classification and Input."),br(),
                      "Description: Briefly describe the data set , GSE15296, authors used for training.", br(),
                      "Exploration: Briefly describe what authors did on data cleaning and the distribution of each sample in this training data set.", br(),
                      "Initial Data Analysis: it contains principle component analysis(PCA), showing the  factors which facilitate the identification of post renal transplant outcomes and the top 50 differentially expressed (DE) genes.", br(),
                      "Classification: Using three predic models which are SVM, RF and KNN to show the Post Renal Transplant Graft Outcome. ", br(),
                      "Input: It is a risk Calculator. It allows users to choose gene expression levels and the calculator will give users the prediction result. ", br(),
                      br(),
                      h4("2. Click the GSE129166 Validation Data tab, there is a menu which contains Description, Exploration, Initial Data Analysis and Classification. "), br(),
                      "Description: Briefly describe the data set , GSE129166, authors used for testing.", br(),
                      "Exploration: Briefly describe what authors did on data cleaning and the distribution of each sample in this testing data set.", br(),
                      "Initial Data Analysis: Principle Component Analysis (PCA) method and visualisation.", br(),
                      "Classification: Building the prediction model using SVM, KNN and RF. Cross-validation accuracies are visualised.", br(), 
                      br(),
                      h4("3. Click the Pathway Analysis tab. it is about With the use of enrichment pathway analysis on our gene set, this function will return the enrichment KEGG categories and a KEGG pathway map which displays the individual gene interaction and reaction network diagram. This will help to provide better insight during high-throughput biological data research."), br(),
                      
                      h4("4. Click the Acknowledge page. This indicates our references."), br(),
                      
             ),
             navbarMenu("GSE15296 Training Data",
                        tabPanel("Description",
                                 br(),
                                 
                                 h2("Description of GSE15296 Training Data"),br(),
                                 h4("Peripheral Blood Biomarker Signatures for Acute Kidney Transplant Rejection"), br(),
                                 "The training data is sourced from the online data repository for functional genomics data, Gene Expression Omnibus (GEO). The training data, GSE15296 explores microarray samples from the peripheral blood of kidney transplant patients. 
                                 The dimensions of the data include 54675 features, and 75 samples. From genome expression profiling of each blood sample, 51 were classified as acute kidney transplant rejection, and 24 are classified as stable with biopsy-proven normal transplant histology. 
                                 The rejection classified samples include four subtypes of acute rejection (AR) including: Banff Borderline, IIA, IA, and IB. It is assumed that kidney transplant rejection is not caused by BK nephropathy, other infections, drug-induced nephrotoxicity or ureteral obstruction.", br(),
                                 br(),
                                 h4("Data Preparation"), br(),
                                 "The classification of stable and rejection patients are stored in the ‘characteristic_ch1.1’ variable and string matching was used to identify stable patients from rejection using “phenotype: Well-functioning kidney transplant”. This is stored in a new variable which is passed into the prediction model. The features were stored as affymetrix gene ids, and were converted to gene symbols for better readability using BioMart. The feature size was reduced to 20520 after this conversion, whilst still maintaining the sample size of 75.", br(),
                                 
                                 
                        ), 
                        tabPanel("Data Exploration", h3("Data Exploration"),
                                 mainPanel(
                                   h4("1. Box-and-whisker plot"),br(),
                                   plotOutput("trainingIDA_boxplot"), br(),
                                   "Calculate and view the distribution of the selected sample values. 
                                   The value is the original data provided by the submitter, and geo2r calculation is performed on this basis. 
                                   Viewing the distribution is important to determine whether the selected samples are suitable for comparison. 
                                   Generally, values centered on intermediate values indicate that the data is standardized and cross comparable.",
                                   br(),
                                   "In this box plot, each sample has a separate box diagram. Through this figure, we can roughly see whether the data has symmetry, 
                                   the degree of dispersion of distribution and other information.From this figure, we can see that after data cleaning, the median of each sample is close to 4. 
                                   The height of the box reflects the fluctuation of the data to a certain extent. In this data set, the height difference of each box(sample) is not very large, 
                                   which means that the fluctuation degree of the data is not very large. There is no outlier in this data set as training dataset.",
                                   br(),
                                   h4("2. Mean-variance trend"), br(),
                                   plotOutput("trainingIDA_distributionplot"),
                                   "This method shows the distribution of (log2 conversion) count data of all samples and allows easy discovery of problems. 
                                   This figure shows the sample distribution of all samples.There is no particularly prominent peak or other particularly prominent value in this figure, which basically overlap.",
                                 )
                        ), 
                        tabPanel("Initial Data Analysis",h3("Principal Component Analysis (PCA)"),br(),
                                 h5("Principle Component Analysis is performed before building the prediction model to explore significant factors in distinguishing a rejection outcome from renal transplantation to a stable outcome. Due to the vast size of the data matrix, and the multitude of components of the microarray, PCA allows a deconstruction of components to focus on the driving factors. The methods used to perform PCA include a comparison between a scatter plot visualisation with and without a filtering method such as feature selection. "),br(),
                        h5("The first PCA visualisation indicates that there is no significant trend used to distinguish rejection from stable samples. This means that even with a focus on the principle variables in the data, there are currently no driving factors which lead to a rejection or stable outcome. To solve this, a filtering strategy of feature selection to select the top 50 differentially expressed genes is performed."),br(),
                                 plotlyOutput(outputId = "pca_train_1"),br(),
                                 
                                 h5("The second PCA visualisation indicates that after the filtering strategy, which infers that rejection patients have a higher principle component 2 compared to the majority of stable patients, and that there is a slightly clearer separation of points compared to the first PCA."),br(),
                                
                                 plotlyOutput(outputId = "pca_train_50")
                        ), 
                        tabPanel("Classification", h3("Prediction Model"), br(), h5("The prediction models chosen include Support-vector Machine (SVM), K-Nearest Neighbours (KNN), and Random Forest (RF). The prediction model is given an input of the top 50 differentially expressed genes from the training dataset, and outputs a prediction: Stable, Rejection. The cross-validation accuracies are displayed in the boxplot."),br(),
                                 plotlyOutput("classifierTrain"),br(),
                                 
                        ), 
                        tabPanel("Input",  
                                 sidebarLayout(
                                   sidebarPanel(
                                     downloadButton('downloadData', 'Download'),
                                     fileInput("file", "Choose CSV File",
                                               accept = c(
                                                 "text/csv",
                                                 "text/comma-separated-values,text/plain",
                                                 ".csv")),
                                   ), 
                                   mainPanel(
                                     h1("Risk Calculator"),
                                     "Explore the likelihood of graft survival using this calculator.",
                                     h2("Instructions:"),
                                     "Download the csv to input your desired expression value from 0 to 16 for each of GSE15296's top 50 differentially expressed genes.We initialize each value to 8. You can modify it to what you want.
                                             Upload the csv and generate an outcome based on our applicable models trained using the top 50 DE matrix. The code will parse the expressions values into our three models where a final outcome based
                                              on majority votes will be displayed.",
                                     h2("Outcomes:"),
                                     "Majority outcome is ",
                                     strong(textOutput(outputId = "total_prediction", inline = T))))),
             ),
             navbarMenu("GSE129166 Validation Data",
                        tabPanel("Description",
                                 br(),
                                 h2("Description of GSE129166 Validation Data"),br(),
                                 h4("Gene Expression Profiling in Patients With a Kidney Transplantation"), br(),
                                 "The validation data is sourced from the online data repository for functional genomics data, Gene Expression Omnibus (GEO). 
                                 The validation data, GSE129166 explores the peripheral blood samples, as well as kidney allograft biopsies to investigate the mRNA expression for renal transplant outcomes. 
                                 The dimensions of the data include 54675 features, and 212 samples. There are 117 peripheral blood samples, and 95 kidney allograft biopsies. 
                                 The rejection classified samples include the subtypes: T-cell mediated rejection (TCMR), Banff borderline, and acute cell-mediated allograft rejection (ACMR). There are 52 rejection samples, and 160 stable samples. ", br(),
                                 br(),
                                 h4("Data Preparation"), br(),
                                 "The data is log2 transformed to normalise the expression of genes to ensure proportional changes are modelled.", br(),
                                 "The rejection and stable phenotype data is extracted from the “tcmr (no:ch1”, and “abmr (no:ch`” variables. The TCMR variable included the banff rejection classification as well as TCMR. String matching was performed to classify stable if both variables displayed “0”, and rejection otherwise. From this, 52 samples were classified as rejection and 150 were stable. The features were stored as affymetrix gene ids, and were converted to gene symbols for better readability using BioMart. The feature size was reduced to 20520 after this conversion, whilst still maintaining the sample size of 212.", br(),
                                 
                                 
                                 
                        ), 
                        tabPanel("Exploration",
                                 mainPanel(
                                   h4("1. Box-and-whisker plot"),br(),
                                   plotOutput("testingIDA_boxplot"), br(),
                                   "Calculate and view the distribution of the selected sample values. 
                                   The value is the original data provided by the submitter, and geo2r calculation is performed on this basis. 
                                   Viewing the distribution is important to determine whether the selected samples are suitable for comparison. 
                                   Generally, values centered on intermediate values indicate that the data is standardized and cross comparable.",
                                   br(),
                                   "In this box plot, each sample has a separate box diagram. Through this figure, we can roughly see whether the data has symmetry, 
                                   the degree of dispersion of distribution and other information.From this figure, we can see that after data cleaning, the median of each sample is close to 5.8. 
                                   The height of the box reflects the fluctuation of the data to a certain extent. In this data set, the height difference of each box(sample) is not very large, 
                                   which means that the fluctuation degree of the data is not very large. There is no outlier in this data set as Validation dataset.",
                                   br(),
                                   h4("2. Mean-variance trend"), br(),
                                   plotOutput("testingIDA_distributionplot"),
                                   "This method shows the distribution of (log2 conversion) count data of all samples and allows easy discovery of problems. 
                                   This figure shows the sample distribution of all samples.There is no particularly prominent peak or other particularly prominent value in this figure, which basically overlap.",
                                 )
                                 ),
                        tabPanel("Initial Data Analysis", h3("Principal Component Analysis (PCA)"),br(),
                                 h5("Principle Component Analysis is performed before building the prediction model to explore significant factors in distinguishing a rejection outcome from renal transplantation to a stable outcome. Due to the vast size of the data matrix, and the multitude of components of the microarray, PCA allows a deconstruction of components to focus on the driving factors. The methods used to perform PCA include a comparison between a scatter plot visualisation with and without a filtering method such as feature selection."), br(), 
                                 h5("The first PCA visualisation indicates two clusters, which can be attributed to the two types of sampling: 1) peripheral blood, 2) kidney biopsy. ") , br(),
                                 plotlyOutput(outputId = "pca_test_1"),br(),
                                 h5("This trend is maintained in the PCA visualisation with feature selection."), br(),
                                 plotlyOutput(outputId = "pca_test_50"), br(),
                                 ), 
                        tabPanel("Classification", h3("Prediction Model"), br(), h5("The prediction models chosen include Support-vector Machine (SVM), K-Nearest Neighbours (KNN), and Random Forest (RF). The prediction model is given an input of the top 50 differentially expressed genes from the training dataset, and outputs a prediction: Stable, Rejection. The cross-validation accuracies are displayed in the boxplot."),br(),
                                 plotlyOutput("classifierTest"),br(),
                                 
                        ), 
             ),
             
              tabPanel("Pathway Analysis", br(),
                                 h2("Gene Pathway Enrichment Analysis"),
                                 br(),
                                 h3("Design and Method"),
                                 br(),
                                 p("This analysis utilised the top 250 differentially expressed genes extracted from the dataset GSE15296 which contained samples of microarray profiles of peripheral blood from kidney transplant recipients. Functional enrichment analysis was performed using the Kyoto Encyclopedia of Genes and Genomes (KEGG). The parameters for the pathway analysis include:  gene: list of genes in gene symbol format; organism: ‘hsa’; pvalueCutoff: 0.05. 
The dot plot visualisation shows 25 up-regulated KEGG pathways, with the size of each dot corresponding to the number of genes enriched in the pathway, and the color of each dot represents the level of significance based on the p-adjusted value. 
The gene-concept network graph depicts the top 6 significant pathways, and the correlation of the top 250 differentially expressed genes between each pathway. The enriched pathways are categorised by colour, with each gene mapped using an undirected edge to a pathway category. The colour of category nodes are tan, and gene nodes are grey. The size of each node corresponds to the number of genes included in the pathway. The genes are labelled according to their gene symbol."),
                                 
                                 
                                 h3("KEGG Pathway Enrichment Analysis Dot Plot"),
                                 br(),
                                 
                                 plotOutput(outputId = "pathway_dotplot"),
                                 br(),
                                 h3("Gene-Concept Network for KEGG Pathways"),
                                 br(),
                                 plotOutput(outputId = "pathway_network"),
                                 br(),
              ),
             tabPanel("Acknowledgements", br(),
                      h2("Links of References:"), br(),
                      "1. GEO Accession viewer. (2022). Retrieved 22 May 2022, from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE15296", br(),
                      "2. GEO Accession viewer. (2022). Retrieved 22 May 2022, from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE129166", br(),
                      "3. Shiny - Gallery. (2022). Retrieved 22 May 2022, from https://shiny.rstudio.com/gallery/", br(),
                      "4. Luo, W. and Brouwer C., Pathview: an R/Bioconductor package for pathway-based data integration and visualization. Bioinformatics, 2013, 29(14): 1830-1831, doi: 10.1093/bioinformatics/btt285", br(),
                      "5. Guangchuang Yu, Li-Gen Wang, Guang-Rong Yan, Qing-Yu He. DOSE: an R/Bioconductor package for Disease Ontology Semantic and Enrichment analysis. Bioinformatics 2015, 31(4):608-609", br(),
                      ) 
  ),
  inverse = T
)






# Define server logic required to draw a histogram
server <- function(input, output,session) {
  
  # Create dataframe of excel template
  data <- reactive({data <- data.frame(gene = NA, expression = rep(8,50))
  data$gene <- colnames(X)
  data})
  
  # Download button the dataframe to csv
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("userinput",".csv",sep="")
    },
    content = function(file) {
      write.csv(data(), file, row.names = FALSE)
    }
  )

  # Render total prediction
  output$total_prediction <- renderText({
    req(input$file)
    inFile <- input$file
    df <- read.csv(inFile$datapath)
    rf_res <- randomForest::randomForest(x = X, y = as.factor(y))
    fit_rf <- predict(rf_res, df$expression)
    
    svm_res <- e1071::svm(x = X, y = as.factor(y))
    svm_data <- data.frame(matrix(8, nrow = 1,ncol = 50))
    colnames(svm_data) <- df$gene
    fit_svm <- predict(svm_res, svm_data)
    
    fit5 = class::knn(train = X, test = df$expression, cl = y, k = 5)
    as.vector(fit5)
    
    votes = c(as.vector(fit5), as.vector(fit_rf),as.vector(fit_svm))
    
    names(which.max(table(votes)))
  })

  
  output$distPlot <- renderPlotly({
    # generate bins based on input$bins from ui.R
    x    <- faithful[, 2]
    bins <- seq(min(x), max(x), length.out = input$bins + 1)
    
    # draw the histogram with the specified number of bins
    hist(x, breaks = bins, col = 'darkgray', border = 'white')
  })
  
  output$classifierTrain <- renderPlotly({
    
    # classifier accuracy plot 
    options(highcharter.theme = hc_theme_smpl(tooltip = list(valueDecimals = 2)))
    
    acc_df <- data.frame(cv_50acc5_knn, cv_50acc5_svm, cv_50acc5_rf)
    
    acc_df$cv_50acc5_knn <- as.factor(acc_df$cv_50acc5_knn)
    acc_df$cv_50acc5_svm <- as.factor(acc_df$cv_50acc5_svm)
    acc_df$cv_50acc5_rf <- as.factor(acc_df$cv_50acc5_rf)
    
    
    p <- plot_ly(type = "box")
    p <- p %>% add_trace(y = acc_df$cv_50acc5_svm, quartilemethod="linear", name = "SVM")
    p <- p %>% add_trace(y = acc_df$cv_50acc5_knn, quartilemethod="linear", name = "KNN")
    p <- p %>% add_trace(y = acc_df$cv_50acc5_rf, quartilemethod="linear", name = "RF")
    
    p <- p %>% layout(title = "Cross Validation Accuracies for Predicting Transplant Outcomes") 
    p
    
  })
  
  # without top 50 de feature selection:
  output$pca_train_1 <- renderPlotly({
    gset_pca <- prcomp(t(ex), scale. = TRUE)
    df_toplot <- data.frame(gset$Outcome, 
                            pc1 = gset_pca$x[,1], pc2 = gset_pca$x[,2])
    
    
    
    g <- plot_ly(df_toplot, x = ~pc1, y = ~pc2, color = ~gset.Outcome, colors = c('#FF3131','#466D1D'), type = 'scatter', mode = 'markers') %>%
      layout(
        legend=list(title=list(text='Outcome')),
        plot_bgcolor='#e5ecf6',
        xaxis = list(
          title = "PC1",
          zerolinecolor = "#ffff",
          zerolinewidth = 1,
          gridcolor='#ffff'),
        yaxis = list(
          title = "PC2",
          zerolinecolor = "#ffff",
          zerolinewidth = 1,
          gridcolor='#ffff'), 
        title = "[GSE15296] PCA Plot Kidney Transplant Patients") 
    g 
    
  })
  
  output$pca_train_50 <- renderPlotly({
    g <- plot_ly(df_toplot, x = ~pc1, y = ~pc2, color = ~featSub$Outcome, colors = c('#FF3131','#466D1D'), type = 'scatter', mode = 'markers')%>%
      layout(
        legend=list(title=list(text='Outcome')),
        plot_bgcolor='#e5ecf6',
        xaxis = list(
          title = "PC1",
          zerolinecolor = "#ffff",
          zerolinewidth = 1,
          gridcolor='#ffff'),
        yaxis = list(
          title = "PC2",
          zerolinecolor = "#ffff",
          zerolinewidth = 1,
          gridcolor='#ffff'), 
        title = "[GSE15296] PCA Plot Kidney Transplant Patients with Top 50 DE Genes") 
    g 
    
  })
  
  output$trainingIDA_boxplot <- renderPlot({
    title <- paste ("GSE15296", "/", annotation(gset), sep ="")
    boxplot(ex, boxwex=0.7, notch=T, main=title, outline=FALSE, las=2)
  })
  
  output$trainingIDA_distributionplot <- renderPlot({
    title <- paste ("GSE15296", "/", annotation(gset), " value distribution", sep ="")
    plotDensities(ex, main=title, legend=F)
  })
  
  output$pathway_dotplot <- renderPlot({
    dotplot(mkk2, showCategory = 25) + ggtitle("Gene Expression") + scale_y_discrete(guide = guide_axis(check.overlap = TRUE))
    
  })
  
  output$pathway_network <- renderPlot({
    options(ggrepel.max.overlaps = Inf)
    
    set.seed(1234)
    # PATHVIEW - user interactivity 
    #citation("pathview")
    
    
    
    
    # change entrez id to gene symbol to be used in the cnet plot -> 
    kegg <- setReadable(mkk2, 'org.Hs.eg.db', 'ENTREZID')
    
    cnetplot(kegg, categorySize="pvalue", foldChange=geneSym, showCategory = 6, colorEdge = TRUE, node_label_size = 1, repel = TRUE, layout = "kk", cex_label_gene = 0.5, cex_category = 0.6) +  ggplot2::labs(title = "Gene-Concept Network for KEGG Pathways") 
    
    
  })
  
  output$contents <- renderTable({
    # table with the expression label of the genes which the user has entered in 
    req(input$userFile)
    
    df <- read.csv(input$userFile$datapath,
                   header = input$header,
                   sep = input$sep,
                   quote = input$quote)
    
    if(input$disp == "head") {
      return(head(df))
    } else {
      return(df)
    }
  })
  
  url1 <- a("GSE15296", href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE15296")
  output$training_link <- renderUI({
    tagList("1. Link of Training data set reference:", url1)
  })
  
  output$testingIDA_boxplot <- renderPlot({
    title <- paste ("GSE129166", "/", annotation(gset2), sep ="")
    boxplot(ex2, boxwex=0.7, notch=T, main=title, outline=FALSE, las=2)
  })
  
  output$testingIDA_distributionplot <- renderPlot({
    title <- paste ("GSE129166", "/", annotation(gset2), " value distribution", sep ="")
    plotDensities(ex2, main=title, legend=F)
  })
  
  # without top 50 de feature selection:
  output$pca_test_1 <- renderPlotly({
    df_toplot2 <- data.frame(gset2$Outcome,
                             pc1 = gset2_pca$x[,1], pc2 = gset2_pca$x[,2])
    fig <- plot_ly(df_toplot2, x = ~pc1, y = ~pc2, color = ~gset2.Outcome, colors = c('#FF3131','#466D1D'), type = 'scatter', mode = 'markers')%>%
      layout(
        legend=list(title=list(text='Outcome')),
        plot_bgcolor='#e5ecf6',
        xaxis = list(
          title = "PC1",
          zerolinecolor = "#ffff",
          zerolinewidth = 2,
          gridcolor='#ffff'),
        yaxis = list(
          title = "PC2",
          zerolinecolor = "#ffff",
          zerolinewidth = 2,
          gridcolor='#ffff'), 
        title = "[GSE129166] PCA Plot Kidney Transplant Patients") 
    fig
    
  })

  output$pca_test_50 <- renderPlotly({
    fig <- plot_ly(df_toplot2, x = ~pc1, y = ~pc2, color = ~featSub2.Outcome, colors = c('#FF3131','#466D1D'), type = 'scatter', mode = 'markers')%>%
      layout(
        legend=list(title=list(text='Outcome')),
        plot_bgcolor='#e5ecf6',
        xaxis = list(
          title = "PC1",
          zerolinecolor = "#ffff",
          zerolinewidth = 2,
          gridcolor='#ffff'),
        yaxis = list(
          title = "PC2",
          zerolinecolor = "#ffff",
          zerolinewidth = 2,
          gridcolor='#ffff'), 
        title = "[GSE129166] PCA Plot Kidney Transplant Patients with Top 50 DE Genes") 
    fig
    
  })
  
  output$classifierTest <- renderPlotly({
    
    # classifier accuracy plot 
    options(highcharter.theme = hc_theme_smpl(tooltip = list(valueDecimals = 2)))
    
    acc_df2 <- data.frame(cv_50acc5_knn2, cv_50acc5_svm2, cv_50acc5_rf2)
    
    acc_df2$cv_50acc5_knn2 <- as.factor(acc_df2$cv_50acc5_knn2)
    acc_df2$cv_50acc5_svm2 <- as.factor(acc_df2$cv_50acc5_svm2)
    acc_df2$cv_50acc5_rf2 <- as.factor(acc_df2$cv_50acc5_rf2)
    
    
    p <- plot_ly(type = "box")
    p <- p %>% add_trace(y = acc_df2$cv_50acc5_svm2, quartilemethod="linear", name = "SVM")
    p <- p %>% add_trace(y = acc_df2$cv_50acc5_knn2, quartilemethod="linear", name = "KNN")
    p <- p %>% add_trace(y = acc_df2$cv_50acc5_rf2, quartilemethod="linear", name = "RF")
    
    p <- p %>% layout(title = "Cross Validation Accuracies for Predicting Transplant Outcomes") 
    p
    
  })
  
}

# Run the application 
shinyApp(ui = ui, server = server) 

